
import { db } from "../db";
import { knowledgeBase } from "@shared/ticket-schema";
import { eq, like, or, desc } from "drizzle-orm";
import type { KnowledgeBaseArticle, NewKnowledgeBaseArticle } from "@shared/ticket-schema";

export interface TicketArticleMatch {
  article: KnowledgeBaseArticle;
  relevanceScore: number;
  matchReasons: string[];
}

export class KnowledgeAIService {
  
  /**
   * Find relevant articles for a ticket
   */
  async findRelevantArticles(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
    tags?: string[];
  }): Promise<TicketArticleMatch[]> {
    try {
      // Get all published articles
      const articles = await db
        .select()
        .from(knowledgeBase)
        .where(eq(knowledgeBase.status, "published"))
        .orderBy(desc(knowledgeBase.helpful_votes));

      if (!articles.length) {
        return [];
      }

      const matches: TicketArticleMatch[] = [];
      const ticketText = `${ticket.title} ${ticket.description}`.toLowerCase();
      const ticketWords = this.extractKeywords(ticketText);

      for (const article of articles) {
        const score = this.calculateRelevanceScore(ticket, article, ticketWords);
        
        if (score.score > 0.3) { // Minimum relevance threshold
          matches.push({
            article,
            relevanceScore: score.score,
            matchReasons: score.reasons
          });
        }
      }

      // Sort by relevance score (highest first)
      return matches.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, 5);

    } catch (error) {
      console.error("Error finding relevant articles:", error);
      return [];
    }
  }

  /**
   * Generate a draft article from ticket content
   */
  async generateDraftArticle(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
    tags?: string[];
  }): Promise<KnowledgeBaseArticle | null> {
    try {
      const draftContent = this.generateArticleContent(ticket);
      
      const newArticle: NewKnowledgeBaseArticle = {
        title: `How to resolve: ${ticket.title}`,
        content: draftContent,
        category: ticket.category || this.categorizeTicket(ticket),
        tags: this.generateArticleTags(ticket),
        author_email: "system@autoGenerated.com",
        status: "draft",
        views: 0,
        helpful_votes: 0
      };

      const [createdArticle] = await db
        .insert(knowledgeBase)
        .values(newArticle)
        .returning();

      console.log(`Generated draft article for ticket: ${ticket.title}`);
      return createdArticle;

    } catch (error) {
      console.error("Error generating draft article:", error);
      return null;
    }
  }

  /**
   * Calculate relevance score between ticket and article
   */
  private calculateRelevanceScore(
    ticket: any, 
    article: KnowledgeBaseArticle, 
    ticketWords: string[]
  ): { score: number; reasons: string[] } {
    let score = 0;
    const reasons: string[] = [];

    const articleTitle = article.title.toLowerCase();
    const articleContent = article.content.toLowerCase();
    const articleCategory = (article.category || "").toLowerCase();

    // Title matches (highest weight)
    const titleMatches = ticketWords.filter(word => 
      word.length > 3 && articleTitle.includes(word)
    );
    if (titleMatches.length > 0) {
      score += titleMatches.length * 0.4;
      reasons.push(`Title keywords: ${titleMatches.join(", ")}`);
    }

    // Category match
    if (ticket.category && articleCategory === ticket.category.toLowerCase()) {
      score += 0.3;
      reasons.push("Category match");
    }

    // Content matches
    const contentMatches = ticketWords.filter(word => 
      word.length > 3 && articleContent.includes(word)
    );
    if (contentMatches.length > 0) {
      score += contentMatches.length * 0.1;
      reasons.push(`Content keywords: ${contentMatches.slice(0, 3).join(", ")}`);
    }

    // Tag matches
    if (article.tags && ticket.tags) {
      const tagMatches = article.tags.filter(tag => 
        ticket.tags!.some(ticketTag => 
          tag.toLowerCase().includes(ticketTag.toLowerCase()) ||
          ticketTag.toLowerCase().includes(tag.toLowerCase())
        )
      );
      if (tagMatches.length > 0) {
        score += tagMatches.length * 0.2;
        reasons.push(`Tag matches: ${tagMatches.join(", ")}`);
      }
    }

    // Error code patterns
    const errorCodes = this.extractErrorCodes(ticket.title + " " + ticket.description);
    if (errorCodes.length > 0) {
      const articleErrorCodes = this.extractErrorCodes(article.title + " " + article.content);
      const errorMatches = errorCodes.filter(code => articleErrorCodes.includes(code));
      if (errorMatches.length > 0) {
        score += errorMatches.length * 0.5;
        reasons.push(`Error codes: ${errorMatches.join(", ")}`);
      }
    }

    // Boost score based on article quality
    score += (article.helpful_votes || 0) * 0.01;
    score += (article.views || 0) * 0.001;

    return { score: Math.min(score, 1.0), reasons };
  }

  /**
   * Extract keywords from text
   */
  private extractKeywords(text: string): string[] {
    const stopWords = new Set([
      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
      'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did',
      'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those'
    ]);

    return text
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 2 && !stopWords.has(word))
      .filter((word, index, arr) => arr.indexOf(word) === index); // Remove duplicates
  }

  /**
   * Extract error codes from text (patterns like ERR001, ERROR-500, etc.)
   */
  private extractErrorCodes(text: string): string[] {
    const errorPattern = /(?:error|err|code)[-_\s]*(\w+\d+|\d+\w*)/gi;
    const matches = text.match(errorPattern) || [];
    return matches.map(match => match.toLowerCase());
  }

  /**
   * Generate article content from ticket
   */
  private generateArticleContent(ticket: any): string {
    const sections = [];

    sections.push("## Issue Description");
    sections.push(ticket.description);

    sections.push("\n## Problem Summary");
    sections.push(`This article addresses the issue: "${ticket.title}"`);

    sections.push("\n## Possible Causes");
    sections.push("- Configuration issues");
    sections.push("- Network connectivity problems");
    sections.push("- Software conflicts");
    sections.push("- User permission issues");

    sections.push("\n## Resolution Steps");
    sections.push("1. **Verify the issue**: Confirm the problem exists and gather relevant information");
    sections.push("2. **Check basic requirements**: Ensure all prerequisites are met");
    sections.push("3. **Apply standard solution**: Follow the recommended resolution process");
    sections.push("4. **Test the fix**: Verify that the issue has been resolved");
    sections.push("5. **Document the outcome**: Record the solution for future reference");

    sections.push("\n## Additional Resources");
    sections.push("- Contact IT Support if the issue persists");
    sections.push("- Check system status page for known issues");

    sections.push("\n---");
    sections.push("*This article was auto-generated from ticket content and requires review before publishing.*");

    return sections.join("\n");
  }

  /**
   * Generate tags for article based on ticket
   */
  private generateArticleTags(ticket: any): string[] {
    const tags = new Set<string>();

    // Add ticket type
    tags.add(ticket.type);

    // Add category if available
    if (ticket.category) {
      tags.add(ticket.category.toLowerCase());
    }

    // Add existing tags
    if (ticket.tags && Array.isArray(ticket.tags)) {
      ticket.tags.forEach(tag => tags.add(tag.toLowerCase()));
    }

    // Extract technical terms from title and description
    const text = `${ticket.title} ${ticket.description}`.toLowerCase();
    
    const technicalTerms = [
      'password', 'login', 'access', 'network', 'vpn', 'email', 'printer', 'software',
      'hardware', 'installation', 'update', 'backup', 'security', 'firewall', 'antivirus',
      'database', 'server', 'application', 'browser', 'windows', 'mac', 'linux'
    ];

    technicalTerms.forEach(term => {
      if (text.includes(term)) {
        tags.add(term);
      }
    });

    tags.add("auto-generated");

    return Array.from(tags);
  }

  /**
   * Categorize ticket based on content
   */
  private categorizeTicket(ticket: any): string {
    const text = `${ticket.title} ${ticket.description}`.toLowerCase();

    const categories = {
      'Hardware': ['hardware', 'printer', 'computer', 'laptop', 'monitor', 'keyboard', 'mouse'],
      'Software': ['software', 'application', 'program', 'install', 'update', 'bug'],
      'Network': ['network', 'internet', 'wifi', 'connection', 'vpn', 'firewall'],
      'Security': ['password', 'login', 'access', 'security', 'antivirus', 'malware'],
      'Email': ['email', 'outlook', 'gmail', 'mail', 'smtp', 'imap'],
      'Account Management': ['account', 'user', 'permission', 'role', 'directory']
    };

    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(keyword => text.includes(keyword))) {
        return category;
      }
    }

    return 'General';
  }
}

export const knowledgeAIService = new KnowledgeAIService();
