
import { db } from "../db";
import { knowledgeBase } from "@shared/ticket-schema";
import { eq, like, or, desc } from "drizzle-orm";
import type { KnowledgeBaseArticle, NewKnowledgeBaseArticle } from "@shared/ticket-schema";

export interface TicketArticleMatch {
  article: KnowledgeBaseArticle;
  relevanceScore: number;
  matchReasons: string[];
}

export class KnowledgeAIService {
  
  /**
   * Find relevant articles for a ticket
   */
  async findRelevantArticles(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
    tags?: string[];
  }): Promise<TicketArticleMatch[]> {
    try {
      console.log('Finding relevant articles for ticket:', ticket.title);
      
      // Get all published articles
      const articles = await db
        .select()
        .from(knowledgeBase)
        .where(eq(knowledgeBase.status, "published"))
        .orderBy(desc(knowledgeBase.helpful_votes));

      console.log(`Found ${articles.length} published articles in database`);

      if (!articles.length) {
        console.log('No published articles found');
        return [];
      }

      const matches: TicketArticleMatch[] = [];
      const ticketText = `${ticket.title} ${ticket.description}`.toLowerCase();
      const ticketWords = this.extractKeywords(ticketText);

      for (const article of articles) {
        const score = this.calculateRelevanceScore(ticket, article, ticketWords);
        
        if (score.score > 0.2) { // Lower threshold for better matching
          matches.push({
            article,
            relevanceScore: score.score,
            matchReasons: score.reasons
          });
        }
      }

      // Sort by relevance score (highest first)
      const sortedMatches = matches.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, 5);
      console.log(`Found ${sortedMatches.length} relevant articles with scores:`, sortedMatches.map(m => ({ id: m.article.id, title: m.article.title, score: m.relevanceScore })));
      
      return sortedMatches;

    } catch (error) {
      console.error("Error finding relevant articles:", error);
      return [];
    }
  }

  /**
   * Generate a draft article from ticket content
   */
  async generateDraftArticle(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
    tags?: string[];
  }): Promise<KnowledgeBaseArticle | null> {
    try {
      console.log('Generating draft article for ticket:', ticket.title);
      
      const draftContent = this.generateArticleContent(ticket);
      
      const newArticle: NewKnowledgeBaseArticle = {
        title: `How to resolve: ${ticket.title}`,
        content: draftContent,
        category: ticket.category || this.categorizeTicket(ticket),
        tags: this.generateArticleTags(ticket),
        author_email: "system@autoGenerated.com",
        status: "published", // Change to published so it's immediately available
        views: 0,
        helpful_votes: 0
      };

      const [createdArticle] = await db
        .insert(knowledgeBase)
        .values(newArticle)
        .returning();

      console.log(`Generated and published draft article: ${createdArticle.id} - ${createdArticle.title}`);
      return createdArticle;

    } catch (error) {
      console.error("Error generating draft article:", error);
      return null;
    }
  }

  /**
   * Calculate relevance score between ticket and article
   */
  private calculateRelevanceScore(
    ticket: any, 
    article: KnowledgeBaseArticle, 
    ticketWords: string[]
  ): { score: number; reasons: string[] } {
    let score = 0;
    const reasons: string[] = [];

    const articleTitle = article.title.toLowerCase();
    const articleContent = article.content.toLowerCase();
    const articleCategory = (article.category || "").toLowerCase();
    const ticketTitle = ticket.title.toLowerCase();

    // Direct title similarity (highest weight)
    const titleWords = ticketTitle.split(' ').filter(word => word.length > 3);
    const titleMatches = titleWords.filter(word => articleTitle.includes(word));
    if (titleMatches.length > 0) {
      score += titleMatches.length * 0.5;
      reasons.push(`Title matches: ${titleMatches.join(", ")}`);
    }

    // Category exact match
    if (ticket.category && articleCategory === ticket.category.toLowerCase()) {
      score += 0.4;
      reasons.push("Category match");
    }

    // Content keyword matches
    const contentMatches = ticketWords.filter(word => 
      word.length > 3 && articleContent.includes(word)
    );
    if (contentMatches.length > 0) {
      score += contentMatches.length * 0.1;
      reasons.push(`Content keywords: ${contentMatches.slice(0, 3).join(", ")}`);
    }

    // Article quality boost
    score += (article.helpful_votes || 0) * 0.01;
    score += (article.views || 0) * 0.001;

    return { score, reasons };
  }

  /**
   * Extract meaningful keywords from text
   */
  private extractKeywords(text: string): string[] {
    const stopWords = new Set(['the', 'is', 'at', 'which', 'on', 'and', 'a', 'to', 'are', 'as', 'was', 'will', 'be', 'have', 'has', 'had', 'do', 'does', 'did', 'can', 'could', 'should', 'would', 'may', 'might', 'must', 'shall', 'will', 'am', 'are', 'is', 'was', 'were', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'shall']);
    
    return text
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 3 && !stopWords.has(word))
      .slice(0, 10); // Limit to top 10 keywords
  }

  /**
   * Generate article content from ticket
   */
  private generateArticleContent(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
  }): string {
    return `# ${ticket.title}

## Problem Description
${ticket.description}

## Troubleshooting Steps

### Step 1: Initial Diagnosis
1. Verify the issue symptoms
2. Check recent changes or updates
3. Review error messages if any

### Step 2: Basic Resolution
1. Restart the affected service/application
2. Check system resources (CPU, Memory, Disk)
3. Verify network connectivity

### Step 3: Advanced Troubleshooting
1. Check system logs for errors
2. Review configuration settings
3. Test with minimal configuration

### Step 4: Escalation
If the above steps don't resolve the issue:
1. Document all attempted solutions
2. Gather system information and logs
3. Contact technical support with detailed information

## Prevention
- Regular system maintenance
- Keep software/drivers updated
- Monitor system performance
- Follow best practices for ${ticket.category || 'system management'}

## Related Topics
- System troubleshooting
- ${ticket.category || 'General'} issues
- Performance optimization

---
*This article was auto-generated from ticket: ${ticket.title}*
*Category: ${ticket.category || 'General'}*
*Type: ${ticket.type}*`;
  }

  /**
   * Generate tags for article
   */
  private generateArticleTags(ticket: {
    title: string;
    description: string;
    category?: string;
    type: string;
    tags?: string[];
  }): string[] {
    const tags = new Set<string>();
    
    // Add existing tags
    if (ticket.tags) {
      ticket.tags.forEach(tag => tags.add(tag.toLowerCase()));
    }
    
    // Add category as tag
    if (ticket.category) {
      tags.add(ticket.category.toLowerCase());
    }
    
    // Add type as tag
    tags.add(ticket.type.toLowerCase());
    
    // Extract keywords from title and description
    const text = `${ticket.title} ${ticket.description}`.toLowerCase();
    const keywords = this.extractKeywords(text);
    keywords.slice(0, 5).forEach(keyword => tags.add(keyword));
    
    // Add common troubleshooting tags
    tags.add('troubleshooting');
    tags.add('support');
    
    return Array.from(tags).slice(0, 8); // Limit to 8 tags
  }

  /**
   * Categorize ticket based on content
   */
  private categorizeTicket(ticket: {
    title: string;
    description: string;
    type: string;
  }): string {
    const text = `${ticket.title} ${ticket.description}`.toLowerCase();
    
    const categoryKeywords = {
      'Hardware': ['hardware', 'device', 'computer', 'laptop', 'desktop', 'monitor', 'keyboard', 'mouse', 'printer', 'scanner'],
      'Software': ['software', 'application', 'program', 'install', 'update', 'crash', 'error', 'bug'],
      'Network': ['network', 'internet', 'wifi', 'connection', 'router', 'vpn', 'firewall'],
      'Security': ['security', 'password', 'login', 'access', 'permission', 'virus', 'malware'],
      'Email & Communication': ['email', 'outlook', 'exchange', 'mail', 'communication', 'messaging'],
      'System Performance': ['slow', 'performance', 'speed', 'freeze', 'hang', 'crash', 'memory', 'cpu']
    };
    
    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      if (keywords.some(keyword => text.includes(keyword))) {
        return category;
      }
    }
    
    return 'Other';
  }
}

export const knowledgeAIService = new KnowledgeAIService();
